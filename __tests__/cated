import { jest } from '@jest/globals';
import { promises as fs } from 'fs';
import * as path from 'path';
import { Command } from 'commander';
import { AeroSSR } from '../src/';

// Mock dependencies
jest.mock('fs', () => ({
  readFileSync: jest.fn(),
  writeFileSync: jest.fn(),
  promises: {
    mkdir: jest.fn(),
    writeFile: jest.fn()
  }
}));
jest.mock('path');
jest.mock('../src/AeroSSR');
jest.mock('commander');

describe('CLI Commands', () => {
  const mockFs = fs as jest.Mocked<typeof fs>;
  const mockPath = path as jest.Mocked<typeof path>;
  const mockReadFileSync = jest.spyOn(require('fs'), 'readFileSync');
  const mockWriteFileSync = jest.spyOn(require('fs'), 'writeFileSync');

  beforeEach(() => {
    jest.clearAllMocks();
    mockPath.resolve.mockImplementation((...parts) => parts.join('/'));
    mockPath.join.mockImplementation((...parts) => parts.join('/'));
    mockReadFileSync.mockImplementation(() => JSON.stringify({
      port: 3000,
      logPath: 'logs/server.log',
      middleware: []
    }));
  });

  describe('init command', () => {
    it('should initialize a new project with default directory', async () => {
      const directory = '.';
      
      await initializeSSR(directory);

      expect(mockFs.mkdir).toHaveBeenCalledWith(expect.stringContaining('public'), { recursive: true });
      expect(mockFs.mkdir).toHaveBeenCalledWith(expect.stringContaining('logs'), { recursive: true });
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('index.html'),
        expect.stringContaining('<!DOCTYPE html>'),
        'utf-8'
      );
    });

    it('should initialize a new project with custom directory', async () => {
      const directory = './custom-dir';
      
      await initializeSSR(directory);

      expect(mockFs.mkdir).toHaveBeenCalledWith(expect.stringContaining('custom-dir/public'), { recursive: true });
      expect(mockFs.mkdir).toHaveBeenCalledWith(expect.stringContaining('custom-dir/logs'), { recursive: true });
    });

    it('should handle initialization errors gracefully', async () => {
      const directory = '.';
      const error = new Error('Permission denied');
      mockFs.mkdir.mockRejectedValue(error);

      const consoleSpy = jest.spyOn(console, 'error');
      
      await expect(initializeSSR(directory)).rejects.toThrow();
      expect(consoleSpy).toHaveBeenCalled();
    });
  });

  describe('middleware command', () => {
    it('should configure middleware with valid options', async () => {
      const app = new AeroSSR();
      const name = 'test-middleware';
      const middlewarePath = './middleware/test.js';

      await configureMiddleware(app, name, middlewarePath);

      expect(app.use).toHaveBeenCalled();
    });

    it('should add static file middleware by default', async () => {
      const app = new AeroSSR();
      
      await configureMiddleware(app);

      expect(app.use).toHaveBeenCalledTimes(3); // Static, logging, and error middleware
    });

    it('should handle middleware configuration errors', async () => {
      const app = new AeroSSR();
      const error = new Error('Invalid middleware');
      jest.spyOn(app, 'use').mockImplementation(() => {
        throw error;
      });

      const consoleSpy = jest.spyOn(console, 'error');
      
      await expect(configureMiddleware(app, 'test', './invalid.js')).rejects.toThrow();
      expect(consoleSpy).toHaveBeenCalled();
    });
  });

  describe('config command', () => {
    it('should load default configuration when file does not exist', () => {
      mockReadFileSync.mockImplementation(() => {
        throw new Error('File not found');
      });

      const config = loadConfig();
      
      expect(config).toEqual({
        port: 3000,
        logPath: 'logs/server.log',
        middleware: []
      });
    });

    it('should save configuration changes', () => {
      const config = {
        port: 4000,
        logPath: 'custom/log.txt',
        middleware: [{ name: 'test', path: './test.js' }]
      };

      saveConfig(config);

      expect(mockWriteFileSync).toHaveBeenCalledWith(
        'aerossr.config.json',
        JSON.stringify(config, null, 2),
        'utf-8'
      );
    });

    it('should update specific configuration values', () => {
      const currentConfig = loadConfig();
      const key = 'port';
      const value = '4000';

      const updatedConfig = {
        ...currentConfig,
        [key]: parseInt(value, 10)
      };

      saveConfig(updatedConfig);

      expect(mockWriteFileSync).toHaveBeenCalledWith(
        'aerossr.config.json',
        expect.stringContaining('"port": 4000'),
        'utf-8'
      );
    });
  });

  describe('Integration Tests', () => {
    it('should initialize project and configure middleware', async () => {
      const directory = './test-project';
      
      // Initialize project
      await initializeSSR(directory);
      
      // Create app instance
      const app = new AeroSSR();
      
      // Configure middleware
      await configureMiddleware(app, 'test', './middleware.js');

      // Verify configuration was saved
      expect(mockWriteFileSync).toHaveBeenCalledWith(
        'aerossr.config.json',
        expect.stringContaining('middleware'),
        'utf-8'
      );
    });

    it('should handle the complete project setup flow', async () => {
      // Initialize project
      await initializeSSR('./test-project');

      // Load config
      const config = loadConfig();
      expect(config.port).toBe(3000);

      // Update config
      const updatedConfig = {
        ...config,
        port: 4000
      };
      saveConfig(updatedConfig);

      // Configure middleware
      const app = new AeroSSR();
      await configureMiddleware(app);

      // Verify everything was called correctly
      expect(mockFs.mkdir).toHaveBeenCalled();
      expect(mockWriteFileSync).toHaveBeenCalled();
      expect(app.use).toHaveBeenCalled();
    });
  });

  describe('Error Handling', () => {
    it('should handle file system errors', async () => {
      mockFs.mkdir.mockRejectedValue(new Error('Permission denied'));
      const consoleSpy = jest.spyOn(console, 'error');

      await expect(initializeSSR('.')).rejects.toThrow('Permission denied');
      expect(consoleSpy).toHaveBeenCalled();
    });

    it('should handle configuration read errors', () => {
      mockReadFileSync.mockImplementation(() => {
        throw new Error('Read error');
      });

      const config = loadConfig();
      expect(config).toEqual(expect.objectContaining({
        port: 3000
      }));
    });

    it('should handle configuration write errors', () => {
      mockWriteFileSync.mockImplementation(() => {
        throw new Error('Write error');
      });

      const consoleSpy = jest.spyOn(console, 'error');
      
      expect(() => saveConfig({ port: 3000, logPath: '', middleware: [] }))
        .toThrow('Write error');
      expect(consoleSpy).toHaveBeenCalled();
    });
  });
});import { IncomingMessage, ServerResponse } from 'http';
import { SecurityMiddleware } from '../src/middlewares/SecurityMiddleware';
import { EventEmitter } from 'events';

describe('SecurityMiddleware', () => {
  // Test utilities
  const createMockRequest = (options: {
    method?: string;
    headers?: Record<string, string>;
    remoteAddress?: string;
  } = {}): IncomingMessage => {
    const req = new EventEmitter() as IncomingMessage;
    req.method = options.method || 'GET';
    req.headers = options.headers || {};
    req.socket = { remoteAddress: options.remoteAddress || '127.0.0.1' } as any;
    return req;
  };

  const createMockResponse = (): jest.Mocked<ServerResponse> => {
    return {
      writeHead: jest.fn(),
      setHeader: jest.fn(),
      end: jest.fn(),
      getHeader: jest.fn(),
    } as unknown as jest.Mocked<ServerResponse>;
  };

  describe('CSRF Protection', () => {
    it('should allow requests with valid CSRF token', async () => {
      const req = createMockRequest({
        headers: { 'x-csrf-token': 'your-csrf-token' }
      });
      const res = createMockResponse();

      await expect(SecurityMiddleware.csrfProtection(req, res)).resolves.toBeUndefined();
      expect(res.writeHead).not.toHaveBeenCalled();
    });

    it('should reject requests with missing CSRF token', async () => {
      const req = createMockRequest();
      const res = createMockResponse();

      await expect(SecurityMiddleware.csrfProtection(req, res)).rejects.toThrow('CSRF token missing or invalid');
      expect(res.writeHead).toHaveBeenCalledWith(403, expect.any(Object));
    });

    it('should reject requests with invalid CSRF token', async () => {
      const req = createMockRequest({
        headers: { 'x-csrf-token': 'invalid-token' }
      });
      const res = createMockResponse();

      await expect(SecurityMiddleware.csrfProtection(req, res)).rejects.toThrow('CSRF token missing or invalid');
      expect(res.writeHead).toHaveBeenCalledWith(403, expect.any(Object));
    });
  });

  describe('Rate Limiting', () => {
    it('should allow requests within rate limit', async () => {
      const rateLimit = SecurityMiddleware.rateLimit(2, 1000);
      const req = createMockRequest();
      const res = createMockResponse();

      await expect(rateLimit(req, res)).resolves.toBeUndefined();
      await expect(rateLimit(req, res)).resolves.toBeUndefined();
    });

    it('should reject requests exceeding rate limit', async () => {
      const rateLimit = SecurityMiddleware.rateLimit(2, 1000);
      const req = createMockRequest();
      const res = createMockResponse();

      await rateLimit(req, res);
      await rateLimit(req, res);
      await expect(rateLimit(req, res)).rejects.toThrow('Too many requests');
      expect(res.writeHead).toHaveBeenCalledWith(429, expect.any(Object));
    });

    it('should reset counter after window expires', async () => {
      jest.useFakeTimers();
      const windowMs = 1000;
      const rateLimit = SecurityMiddleware.rateLimit(2, windowMs);
      const req = createMockRequest();
      const res = createMockResponse();

      await rateLimit(req, res);
      await rateLimit(req, res);
      
      // Advance time beyond window
      jest.advanceTimersByTime(windowMs + 100);
      
      // Should allow requests again
      await expect(rateLimit(req, res)).resolves.toBeUndefined();
      
      jest.useRealTimers();
    });

    it('should handle requests from different IPs separately', async () => {
      const rateLimit = SecurityMiddleware.rateLimit(2, 1000);
      const req1 = createMockRequest({ remoteAddress: '1.1.1.1' });
      const req2 = createMockRequest({ remoteAddress: '2.2.2.2' });
      const res = createMockResponse();

      // First IP
      await rateLimit(req1, res);
      await rateLimit(req1, res);
      await expect(rateLimit(req1, res)).rejects.toThrow('Too many requests');

      // Second IP should still be allowed
      await expect(rateLimit(req2, res)).resolves.toBeUndefined();
    });
  });

  describe('Security Headers', () => {
    it('should set all required security headers', async () => {
      const req = createMockRequest();
      const res = createMockResponse();

      await SecurityMiddleware.securityHeaders(req, res);

      expect(res.setHeader).toHaveBeenCalledWith('X-Content-Type-Options', 'nosniff');
      expect(res.setHeader).toHaveBeenCalledWith('X-Frame-Options', 'DENY');
      expect(res.setHeader).toHaveBeenCalledWith('Strict-Transport-Security', 
        'max-age=31536000; includeSubDomains');
      expect(res.setHeader).toHaveBeenCalledWith('Content-Security-Policy', 
        "default-src 'self'");
    });
  });

  describe('Input Sanitization', () => {
    it('should sanitize POST request body', async () => {
      const req = createMockRequest({ method: 'POST' });
      const res = createMockResponse();

      const sanitizePromise = SecurityMiddleware.sanitizeInput(req, res);
      
      // Simulate request data
      req.emit('data', JSON.stringify({
        text: '<script>alert("xss")</script>',
        name: "O'Reilly & Sons"
      }));
      req.emit('end');

      await sanitizePromise;

      expect(req.body).toEqual({
        text: '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;',
        name: "O&#39;Reilly &amp; Sons"
      });
    });

    it('should handle invalid JSON in request body', async () => {
      const req = createMockRequest({ method: 'POST' });
      const res = createMockResponse();

      const sanitizePromise = SecurityMiddleware.sanitizeInput(req, res);
      
      // Simulate invalid JSON data
      req.emit('data', 'invalid json{');
      req.emit('end');

      await sanitizePromise;

      expect(res.writeHead).toHaveBeenCalledWith(400, expect.any(Object));
      expect(res.end).toHaveBeenCalledWith('Invalid JSON');
    });

    it('should only sanitize string values', async () => {
      const req = createMockRequest({ method: 'POST' });
      const res = createMockResponse();

      const sanitizePromise = SecurityMiddleware.sanitizeInput(req, res);
      
      // Simulate request with mixed data types
      req.emit('data', JSON.stringify({
        text: '<script>alert("xss")</script>',
        number: 42,
        boolean: true,
        object: { nested: '<b>test</b>' }
      }));
      req.emit('end');

      await sanitizePromise;

      expect(req.body).toEqual({
        text: '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;',
        number: 42,
        boolean: true,
        object: { nested: '&lt;b&gt;test&lt;/b&gt;' }
      });
    });

    it('should ignore non-POST/PUT requests', async () => {
      const req = createMockRequest({ method: 'GET' });
      const res = createMockResponse();

      await SecurityMiddleware.sanitizeInput(req, res);

      expect(req.body).toBeUndefined();
    });
  });

  describe('Integration Tests', () => {
    it('should work with all middleware combined', async () => {
      const req = createMockRequest({
        method: 'POST',
        headers: { 'x-csrf-token': 'your-csrf-token' }
      });
      const res = createMockResponse();

      // Apply all middleware
      await SecurityMiddleware.csrfProtection(req, res);
      await SecurityMiddleware.securityHeaders(req, res);
      const rateLimit = SecurityMiddleware.rateLimit(5, 1000);
      await rateLimit(req, res);
      await SecurityMiddleware.sanitizeInput(req, res);

      // Simulate POST data
      req.emit('data', JSON.stringify({ text: '<script>alert("test")</script>' }));
      req.emit('end');

      // Verify all middleware effects
      expect(res.setHeader).toHaveBeenCalledWith('X-Content-Type-Options', 'nosniff');
      expect(req.body.text).toBe('&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;');
    });
  });
});import { StaticFileMiddleware } from '../../src/middlewares/StaticFileMiddleware';
import { IncomingMessage, ServerResponse } from 'http';
import { Readable, Transform } from 'stream';
import { stat, readFile } from 'fs/promises';
import * as path from 'path';
import { gzip, createGzip } from 'zlib';
import { promisify } from 'util';
import * as fs from 'fs';

jest.mock('fs/promises');
jest.mock('path');
jest.mock('zlib');
jest.mock('fs');

const gzipAsync = promisify(gzip) as unknown as jest.MockedFunction<typeof promisify>;

describe('StaticFileMiddleware', () => {
  let middleware: StaticFileMiddleware;
  const mockStat = stat as jest.MockedFunction<typeof stat>;
  const mockReadFile = readFile as jest.MockedFunction<typeof readFile>;
  const mockPath = path as jest.Mocked<typeof path>;
  const mockCreateReadStream = jest.spyOn(fs, 'createReadStream');
  const mockCreateGzip = createGzip as jest.MockedFunction<typeof createGzip>;
  
  beforeEach(() => {
    jest.clearAllMocks();
    middleware = new StaticFileMiddleware({
      root: '/test/public',
      maxAge: 3600,
      compression: true
    });

    mockPath.normalize.mockImplementation(p => p);
    mockPath.join.mockImplementation((...parts) => parts.join('/'));
    mockPath.extname.mockImplementation(p => '.' + p.split('.').pop());
    
    // Setup mock stream
    const mockStream = new Transform({
      transform(chunk, encoding, callback) {
        callback(null, chunk);
      }
    });
    mockCreateReadStream.mockReturnValue(mockStream as any);
    (mockCreateGzip as jest.Mock).mockReturnValue(mockStream);
  });

  const createMockRequest = (method: string = 'GET', url: string = '/', headers = {}): IncomingMessage => {
    const req = new Readable() as IncomingMessage;
    req.method = method;
    req.url = url;
    req.headers = headers;
    return req;
  };

  const createMockResponse = (): jest.Mocked<ServerResponse> => {
    const res = {
      writeHead: jest.fn(),
      setHeader: jest.fn(),
      end: jest.fn(),
      on: jest.fn(),
      once: jest.fn(),
      emit: jest.fn(),
      pipe: jest.fn(),
    } as unknown as jest.Mocked<ServerResponse>;
    return res;
  };

  describe('Configuration', () => {
    it('should use default options when not provided', () => {
      const defaultMiddleware = new StaticFileMiddleware({ root: '/test' });
      expect(defaultMiddleware['maxAge']).toBe(86400);
      expect(defaultMiddleware['compression']).toBe(true);
      expect(defaultMiddleware['dotFiles']).toBe('ignore');
      expect(defaultMiddleware['index']).toEqual(['index.html']);
      expect(defaultMiddleware['etag']).toBe(true);
    });

    it('should use provided options', () => {
      const customMiddleware = new StaticFileMiddleware({
        root: '/test',
        maxAge: 7200,
        compression: false,
        dotFiles: 'allow',
        index: ['index.htm'],
        etag: false
      });

      expect(customMiddleware['maxAge']).toBe(7200);
      expect(customMiddleware['compression']).toBe(false);
      expect(customMiddleware['dotFiles']).toBe('allow');
      expect(customMiddleware['index']).toEqual(['index.htm']);
      expect(customMiddleware['etag']).toBe(false);
    });
  });

  describe('Request Handling', () => {
    it('should call next() for non-GET/HEAD requests', async () => {
      const req = createMockRequest('POST');
      const res = createMockResponse();
      const next = jest.fn();

      await middleware.middleware()(req, res, next);
      expect(next).toHaveBeenCalled();
      expect(res.writeHead).not.toHaveBeenCalled();
    });

    it('should handle HEAD requests same as GET but without body', async () => {
      const req = createMockRequest('HEAD', '/test.txt');
      const res = createMockResponse();
      const next = jest.fn();

      mockStat.mockResolvedValueOnce({
        isFile: () => true,
        isDirectory: () => false,
        mtime: new Date(),
        size: 500, // Small file
      } as any);

      mockReadFile.mockResolvedValueOnce(Buffer.from('content'));

      await middleware.middleware()(req, res, next);
      expect(res.writeHead).toHaveBeenCalledWith(200, expect.any(Object));
      expect(res.end).toHaveBeenCalled();
    });

    it('should handle large files with streaming', async () => {
      const req = createMockRequest('GET', '/large-file.txt');
      const res = createMockResponse();
      const next = jest.fn();

      mockStat.mockResolvedValueOnce({
        isFile: () => true,
        isDirectory: () => false,
        mtime: new Date(),
        size: 2 * 1024 * 1024, // 2MB file
      } as any);

      await middleware.middleware()(req, res, next);
      expect(mockCreateReadStream).toHaveBeenCalled();
    });

    it('should handle conditional requests with If-Modified-Since', async () => {
      const lastModified = new Date();
      const req = createMockRequest('GET', '/test.txt', {
        'if-modified-since': lastModified.toUTCString()
      });
      const res = createMockResponse();
      const next = jest.fn();

      mockStat.mockResolvedValueOnce({
        isFile: () => true,
        isDirectory: () => false,
        mtime: lastModified,
        size: 500,
      } as any);

      await middleware.middleware()(req, res, next);
      expect(res.writeHead).toHaveBeenCalledWith(304);
    });
  });

  describe('Security', () => {
    it('should handle dotfiles with deny configuration', async () => {
      const restrictedMiddleware = new StaticFileMiddleware({
        root: '/test',
        dotFiles: 'deny'
      });

      const req = createMockRequest('GET', '/.hidden');
      const res = createMockResponse();
      const next = jest.fn();

      await restrictedMiddleware.middleware()(req, res, next);
      expect(res.writeHead).toHaveBeenCalledWith(403, { 'Content-Type': 'text/plain' });
      expect(res.end).toHaveBeenCalledWith('Forbidden');
      expect(next).not.toHaveBeenCalled();
    });

    it('should prevent directory traversal attempts', async () => {
      const req = createMockRequest('GET', '/../secret.txt');
      const res = createMockResponse();
      const next = jest.fn();

      mockPath.normalize.mockReturnValueOnce('/../secret.txt');
      mockPath.join.mockReturnValueOnce('/test/public/../secret.txt');
      
      await middleware.middleware()(req, res, next);
      expect(res.writeHead).toHaveBeenCalledWith(403);
      expect(res.end).toHaveBeenCalledWith('Forbidden');
    });
  });

  describe('Compression', () => {
    it('should use streaming compression for large files', async () => {
      const req = createMockRequest('GET', '/large-file.txt', {
        'accept-encoding': 'gzip'
      });
      const res = createMockResponse();
      const next = jest.fn();

      mockStat.mockResolvedValueOnce({
        isFile: () => true,
        isDirectory: () => false,
        mtime: new Date(),
        size: 2 * 1024 * 1024, // 2MB file
      } as any);

      await middleware.middleware()(req, res, next);
      expect(mockCreateGzip).toHaveBeenCalled();
      expect(res.writeHead).toHaveBeenCalledWith(200, expect.objectContaining({
        'Content-Encoding': 'gzip',
        'Vary': 'Accept-Encoding'
      }));
    });

    it('should use buffer compression for small files', async () => {
      const req = createMockRequest('GET', '/small-file.txt', {
        'accept-encoding': 'gzip'
      });
      const res = createMockResponse();
      const next = jest.fn();

      mockStat.mockResolvedValueOnce({
        isFile: () => true,
        isDirectory: () => false,
        mtime: new Date(),
        size: 2000, // Small file
      } as any);

      const content = Buffer.from('x'.repeat(2000));
      mockReadFile.mockResolvedValueOnce(content);
      (gzip as unknown as jest.Mock).mockImplementation((buffer, callback) => 
        callback(null, Buffer.from('compressed')));

      await middleware.middleware()(req, res, next);
      expect(gzip).toHaveBeenCalled();
      expect(res.writeHead).toHaveBeenCalledWith(200, expect.objectContaining({
        'Content-Encoding': 'gzip',
        'Vary': 'Accept-Encoding'
      }));
    });
  });

  describe('Error Handling', () => {
    it('should handle ENOENT with next()', async () => {
      const req = createMockRequest('GET', '/missing.txt');
      const res = createMockResponse();
      const next = jest.fn();

      const error = new Error('ENOENT');
      (error as NodeJS.ErrnoException).code = 'ENOENT';
      mockStat.mockRejectedValueOnce(error);

      await middleware.middleware()(req, res, next);
      expect(next).toHaveBeenCalled();
    });

    it('should handle other errors with 500', async () => {
      const req = createMockRequest('GET', '/error.txt');
      const res = createMockResponse();
      const next = jest.fn();

      mockStat.mockRejectedValueOnce(new Error('Unknown error'));

      await middleware.middleware()(req, res, next);
      expect(res.writeHead).toHaveBeenCalledWith(500);
      expect(res.end).toHaveBeenCalledWith('Internal Server Error');
    });

    it('should handle stream errors', async () => {
      const req = createMockRequest('GET', '/large-file.txt');
      const res = createMockResponse();
      const next = jest.fn();

      mockStat.mockResolvedValueOnce({
        isFile: () => true,
        isDirectory: () => false,
        mtime: new Date(),
        size: 2 * 1024 * 1024,
      } as any);

      const mockStream = new Transform({
        transform(chunk, encoding, callback) {
          callback(new Error('Stream error'));
        }
      });
      mockCreateReadStream.mockReturnValueOnce(mockStream as any);

      await middleware.middleware()(req, res, next);
      // Stream error handling is done through event handlers
      mockStream.emit('error', new Error('Stream error'));
    });
  });

  describe('MIME Types', () => {
    it.each([
      ['.html', 'text/html'],
      ['.css', 'text/css'],
      ['.js', 'application/javascript'],
      ['.json', 'application/json'],
      ['.png', 'image/png'],
      ['.jpg', 'image/jpeg'],
      ['.svg', 'image/svg+xml'],
      ['.wasm', 'application/wasm'],
      ['.unknown', 'application/octet-stream']
    ])('should return correct MIME type for %s extension', async (ext, expectedMime) => {
      const req = createMockRequest('GET', `/test${ext}`);
      const res = createMockResponse();
      const next = jest.fn();

      mockStat.mockResolvedValueOnce({
        isFile: () => true,
        isDirectory: () => false,
        mtime: new Date(),
      } as any);

      mockReadFile.mockResolvedValueOnce(Buffer.from('content'));
      mockPath.extname.mockReturnValueOnce(ext);

      await middleware.middleware()(req, res, next);
      expect(res.writeHead).toHaveBeenCalledWith(expect.any(Number), expect.objectContaining({
        'Content-Type': expectedMime
      }));
    });
  });
});import { AddressInfo } from 'net';
import { IncomingMessage, ServerResponse } from 'http';
import { jest } from '@jest/globals';
import AeroSSR from '../../src/AeroSSR';
import { Logger } from '../../src/utils/logger';
import * as fs from 'fs/promises';
import * as path from 'path';
import fetch from 'node-fetch';

// Mock all required dependencies
jest.mock('fs/promises');
jest.mock('../src/utils/logger');
jest.mock('../src/utils/bundler');
jest.mock('fs', () => ({
  existsSync: jest.fn(),
  mkdirSync: jest.fn(),
  constants: { W_OK: 4, R_OK: 4 },
}));
jest.mock('path');

// Test utilities
const createMockRequest = (method: string = 'GET', url: string = '/', headers = {}): IncomingMessage => {
  return {
    method,
    url,
    headers,
    socket: { remoteAddress: '127.0.0.1' }
  } as unknown as IncomingMessage;
};

const createMockResponse = (): ServerResponse => {
  return {
    writeHead: jest.fn(),
    setHeader: jest.fn(),
    end: jest.fn(),
    headersSent: false
  } as unknown as jest.Mocked<ServerResponse>;
};

describe('AeroSSR Core Tests', () => {
  let aerossr: AeroSSR;
  let mockFs: jest.Mocked<typeof fs>;
  
  beforeEach(() => {
    jest.clearAllMocks();
    aerossr = new AeroSSR({
      port: Math.floor(3000 + Math.random() * 1000),
      logFilePath: null
    });
    mockFs = fs as jest.Mocked<typeof fs>;
    mockFs.readFile.mockResolvedValue('<html><head></head><body></body></html>');
  });

  afterEach(async () => {
    await aerossr.stop();
  });

  describe('Configuration', () => {
    it('should use default configuration values', () => {
      const defaultAero = new AeroSSR();
      expect(defaultAero.config.port).toBe(3000);
      expect(defaultAero.config.compression).toBe(true);
      expect(defaultAero.config.corsOrigins).toEqual({ origins: '*' });
      expect(defaultAero.config.cacheMaxAge).toBe(3600);
      expect(defaultAero.config.logFilePath).toBeNull();
    });

    it('should override default configuration with provided values', () => {
      const customAero = new AeroSSR({
        port: 4000,
        compression: false,
        corsOrigins: { origins: 'http://localhost' },
        cacheMaxAge: 7200,
        logFilePath: 'test.log'
      });

      expect(customAero.config.port).toBe(4000);
      expect(customAero.config.compression).toBe(false);
      expect(customAero.config.corsOrigins).toEqual({ origins: 'http://localhost' });
      expect(customAero.config.cacheMaxAge).toBe(7200);
      expect(customAero.config.logFilePath).toBe('test.log');
    });
  });

  describe('Middleware', () => {
    it('should execute middleware in correct order', async () => {
      const order: number[] = [];
      
      const middleware1 = async (_req: IncomingMessage, _res: ServerResponse, next: () => Promise<void>) => {
        order.push(1);
        await next();
      };
      
      const middleware2 = async (_req: IncomingMessage, _res: ServerResponse, next: () => Promise<void>) => {
        order.push(2);
        await next();
      };

      aerossr.use(middleware1);
      aerossr.use(middleware2);

      const server = await aerossr.start();
      const address = server.address() as AddressInfo;

      await fetch(`http://localhost:${address.port}/`);
      expect(order).toEqual([1, 2]);
    });

    it('should handle middleware errors', async () => {
      const errorMiddleware = async () => {
        throw new Error('Middleware error');
      };

      aerossr.use(errorMiddleware);
      const server = await aerossr.start();
      const address = server.address() as AddressInfo;

      const response = await fetch(`http://localhost:${address.port}/`);
      expect(response.status).toBe(500);
    });
  });

});

describe('Logger Tests', () => {
  const mockFs = fs as jest.Mocked<typeof fs>;
  const mockPath = path as jest.Mocked<typeof path>;
  const mockFsSync = require('fs') as jest.Mocked<typeof import('fs')>;
  const testLogPath = '/test/logs/test.log';
  const testLogDir = '/test/logs';

  beforeEach(() => {
    jest.clearAllMocks();
    mockPath.dirname.mockReturnValue(testLogDir);
    mockFsSync.existsSync.mockReturnValue(true);
    mockFsSync.mkdirSync.mockReturnValue(undefined);
    mockFs.appendFile.mockResolvedValue(undefined);
    mockFs.writeFile.mockResolvedValue(undefined);
  });

  describe('Initialization', () => {
    it('should create logger without file path', () => {
      const logger = new Logger();
      expect(logger).toBeDefined();
      expect(logger.getLogPath()).toBeNull();
    });

    it('should create logger with valid file path', () => {
      const logger = new Logger({ logFilePath: testLogPath });
      expect(logger.getLogPath()).toBe(testLogPath);
    });

    it('should create log directory if it does not exist', () => {
      mockFsSync.existsSync.mockReturnValue(false);
      new Logger({ logFilePath: testLogPath });
      expect(mockFsSync.mkdirSync).toHaveBeenCalledWith(testLogDir, { recursive: true });
    });
  });

});

// Integration Tests
describe('Integration Tests', () => {
  let aerossr: AeroSSR;
  let logger: Logger;

  beforeEach(() => {
    logger = new Logger({ logFilePath: null });
    aerossr = new AeroSSR({ 
      port: Math.floor(3000 + Math.random() * 1000),
      logFilePath: null,
      logger 
    });
  });

  afterEach(async () => {
    await aerossr.stop();
  });

  it('should log requests through the server', async () => {
    const logSpy = jest.spyOn(logger, 'logRequest');
    
    const server = await aerossr.start();
    const address = server.address() as AddressInfo;

    await fetch(`http://localhost:${address.port}/test`);
    
    expect(logSpy).toHaveBeenCalled();
  });

  it('should handle errors and log them', async () => {
    const logSpy = jest.spyOn(logger, 'log');
    
    aerossr.route('/error', async () => {
      throw new Error('Test error');
    });

    const server = await aerossr.start();
    const address = server.address() as AddressInfo;

    await fetch(`http://localhost:${address.port}/error`);
    
    expect(logSpy).toHaveBeenCalledWith(expect.stringContaining('Test error'));
  });

  it('should use logger for server lifecycle events', async () => {
    const logSpy = jest.spyOn(logger, 'log');
    
    await aerossr.start();
    await aerossr.stop();
    
    expect(logSpy).toHaveBeenCalledWith(expect.stringContaining('running on port'));
    expect(logSpy).toHaveBeenCalledWith('Server stopped');
  });
});

describe('AeroSSR Core', () => {
  let aerossr: AeroSSR;
  
  beforeEach(() => {
    aerossr = new AeroSSR();
  });

  afterEach(async () => {
    await aerossr.stop();
  });

  describe('Configuration', () => {
    it('should initialize with default config', () => {
      expect(aerossr.config.port).toBe(3000);
      expect(aerossr.config.compression).toBe(true);
    });

    it('should override defaults with custom config', () => {
      const customAero = new AeroSSR({
        port: 4000,
        compression: false
      });
      expect(customAero.config.port).toBe(4000);
      expect(customAero.config.compression).toBe(false);
    });
  });

  describe('Server Lifecycle', () => {
    it('should start and stop server', async () => {
      const server = await aerossr.start();
      expect(server.listening).toBe(true);
      await aerossr.stop();
      expect(server.listening).toBe(false);
    });

    it('should handle start errors', async () => {
      // Start server on same port to cause conflict
      const server1 = new AeroSSR({ port: 5000 });
      const server2 = new AeroSSR({ port: 5000 });
      
      await server1.start();
      await expect(server2.start()).rejects.toThrow();
      await server1.stop();
    });
  });

  describe('Request Handling', () => {
    it('should handle GET requests', async () => {
      aerossr.route('/test', async (req, res) => {
        res.writeHead(200);
        res.end('success');
      });

      const server = await aerossr.start();
      const address = server.address() as AddressInfo | null;
      if (address) {
        const response = await fetch(`http://localhost:${address.port}/test`);
        expect(response.status).toBe(200);
        expect(await response.text()).toBe('success');
      } else {
        throw new Error('Server address is null');
      }
      expect(response.status).toBe(200);
      expect(await response.text()).toBe('success');
    });

    it('should handle 404s', async () => {
      const server = await aerossr.start();
      const response = await fetch(`http://localhost:${server.address().port}/notfound`);
      expect(response.status).toBe(404);
    });

    it('should execute middleware chain', async () => {
      const order: number[] = [];
      
      aerossr.use(async (req, res, next) => {
        order.push(1);
        await next();
      });

      aerossr.use(async (req, res, next) => {
        order.push(2);
        await next();
      });

      const server = await aerossr.start();
      await fetch(`http://localhost:${server.address().port}/`);
      expect(order).toEqual([1, 2]);
    });
  });
});import { PathLike } from 'fs';
import { resolveDependencies, minifyBundle, generateBundle } from '../../src/utils/bundler';
import * as fs from 'fs/promises';
import * as path from 'path';

jest.mock('fs/promises');
jest.mock('path');

describe('Bundler', () => {
  const mockFs = fs as jest.Mocked<typeof fs>;
  const mockPath = path as jest.Mocked<typeof path>;

  beforeEach(() => {
    jest.clearAllMocks();
    mockPath.resolve.mockImplementation((...parts) => parts.join('/'));
    mockPath.dirname.mockImplementation((p) => p.split('/').slice(0, -1).join('/'));
    mockPath.relative.mockImplementation((from, to) => to.replace(from + '/', ''));
    mockPath.join.mockImplementation((...parts) => parts.join('/'));
  });

  describe('resolveDependencies', () => {
    it('should resolve direct dependencies', async () => {
      mockFs.readFile.mockImplementation(async (filePath) => {
        if (filePath === 'entry.js') {
          return `const dep = require('./dependency.js');\nconsole.log(dep);`;
        }
        return '';
      });

      mockFs.access.mockResolvedValue(undefined);

      const deps = await resolveDependencies('entry.js');
      expect(deps.has('entry.js')).toBe(true);
      expect(deps.has('dependency.js')).toBe(true);
    });

    it('should handle circular dependencies', async () => {
      mockFs.readFile.mockImplementation(async (filePath) => {
        if (filePath === 'a.js') {
          return `require('./b.js')`;
        }
        if (filePath === 'b.js') {
          return `require('./a.js')`;
        }
        return '';
      });

      mockFs.access.mockResolvedValue(undefined);

      const deps = await resolveDependencies('a.js');
      expect(deps.has('a.js')).toBe(true);
      expect(deps.has('b.js')).toBe(true);
      expect(deps.size).toBe(2);
    });

    it('should respect maxDepth option', async () => {
      mockFs.readFile.mockImplementation(async (filePath) => {
        const num = parseInt((filePath as string).match(/\d+/)?.[0] || '0');
        return `require('./dep${num + 1}.js')`;
      });

      mockFs.access.mockResolvedValue(undefined);

      const deps = await resolveDependencies('dep0.js', new Set(), { maxDepth: 2 });
      expect(deps.size).toBeLessThanOrEqual(3); // dep0.js, dep1.js, dep2.js
    });

    it('should handle various import patterns', async () => {
      const testCode = `
        import defaultExport from "./module1";
        import * as name from "./module2";
        import { export1 } from "./module3";
        require('./module4');
        import('./module5');
        export * from './module6';
      `;

      mockFs.readFile.mockImplementation(async () => testCode);
      mockFs.access.mockResolvedValue(undefined);

      const deps = await resolveDependencies('test.js');
      expect(deps.size).toBeGreaterThan(1);
    });
  });

  describe('minifyBundle', () => {
    it('should preserve string contents', () => {
      const code = `const str = "  spaces  in  string  ";`;
      const minified = minifyBundle(code);
      expect(minified).toContain('"  spaces  in  string  "');
    });

    it('should remove comments', () => {
      const code = `
        // Single line comment
        const a = 1;
        /* Multi-line
           comment */
        const b = 2;
      `;
      const minified = minifyBundle(code);
      expect(minified).not.toContain('comment');
      expect(minified).toContain('const a=1');
      expect(minified).toContain('const b=2');
    });

    it('should handle escaped quotes in strings', () => {
      const code = `const str = "string with \\"quotes\\"";`;
      const minified = minifyBundle(code);
      expect(minified).toContain('\\"quotes\\"');
    });

    it('should preserve necessary whitespace', () => {
      const code = `const a = 1; return a + b;`;
      const minified = minifyBundle(code);
      expect(minified).toContain('return a + b');
    });
  });

  describe('generateBundle', () => {
    it('should generate bundle with resolved dependencies', async () => {
      const mockDeps = new Map([
        ['index.js', `import { helper } from './helper';\nconsole.log(helper());`],
        ['helper.js', `export const helper = () => 'helper';`]
      ]);

      mockFs.readFile.mockImplementation(async (filePath: PathLike | fs.FileHandle) => {
        const key = Array.from(mockDeps.keys()).find(k => (filePath as string).endsWith(k));
        return key ? mockDeps.get(key)! : '';
      });

      mockFs.access.mockResolvedValue(undefined);

      const bundle = await generateBundle('/project', 'index.js');
      expect(bundle).toContain('helper');
      expect(bundle).toContain('console.log');
    });

    it('should handle bundle generation errors', async () => {
      mockFs.readFile.mockRejectedValue(new Error('File not found'));

      await expect(generateBundle('/project', 'missing.js')).rejects.toThrow();
    });

    it('should respect minification option', async () => {
      mockFs.readFile.mockResolvedValue('const x = 1;\n\nconst y = 2;');
      mockFs.access.mockResolvedValue(undefined);

      const unminified = await generateBundle('/project', 'test.js', { minify: false });
      const minified = await generateBundle('/project', 'test.js', { minify: true });

      expect(unminified.length).toBeGreaterThan(minified.length);
      expect(unminified).toContain('\n');
      expect(minified).not.toContain('\n');
    });

    it('should respect comments option', async () => {
      mockFs.readFile.mockResolvedValue('const x = 1;');
      mockFs.access.mockResolvedValue(undefined);

      const withComments = await generateBundle('/project', 'test.js', { 
        comments: true,
        minify: false
      });
      const withoutComments = await generateBundle('/project', 'test.js', {
        comments: false,
        minify: false
      });

      expect(withComments).toContain('// File:');
      expect(withoutComments).not.toContain('// File:');
    });
  });
});import { createCache } from '../../src/utils/cache';

describe('Cache Store', () => {
  it('should store and retrieve values', () => {
    const cache = createCache<string>();
    cache.set('key', 'value');
    expect(cache.get('key')).toBe('value');
  });

  it('should handle TTL expiration', async () => {
    const cache = createCache<string>({ ttl: 100 });
    cache.set('key', 'value');
    expect(cache.get('key')).toBe('value');
    
    await new Promise(resolve => setTimeout(resolve, 150));
    expect(cache.get('key')).toBeUndefined();
  });

  it('should respect max size limit', () => {
    const cache = createCache<string>({ maxSize: 2 });
    cache.set('key1', 'value1');
    cache.set('key2', 'value2');
    cache.set('key3', 'value3');
    expect(cache.get('key1')).toBeUndefined();
    expect(cache.get('key2')).toBe('value2');
    expect(cache.get('key3')).toBe('value3');
  });
});
describe('Cache Utility', () => {
  describe('createCache', () => {
    it('should create empty cache', () => {
      const cache = createCache<string>();
      expect(cache.get('test')).toBeUndefined();
    });

    it('should set and get values', () => {
      const cache = createCache<string>();
      cache.set('key', 'value');
      expect(cache.get('key')).toBe('value');
    });

    it('should clear all values', () => {
      const cache = createCache<string>();
      cache.set('key1', 'value1');
      cache.set('key2', 'value2');
      cache.clear();
      expect(cache.get('key1')).toBeUndefined();
      expect(cache.get('key2')).toBeUndefined();
    });
  });
});import { setCookie, getCookie, deleteCookie } from '../../src/utils/cookie';

describe('Cookie Utilities', () => {
  let documentCookies: string[] = [];

  beforeEach(() => {
    // Reset cookies before each test
    documentCookies = [];

    // Mock document.cookie getter and setter
    Object.defineProperty(document, 'cookie', {
      get: jest.fn(() => documentCookies.join('; ')),
      set: jest.fn((value: string) => {
        // Handle cookie deletion
        if (value.includes('Max-Age=-99999999')) {
          const cookieName = value.split('=')[0];
          documentCookies = documentCookies.filter(cookie => 
            !cookie.startsWith(cookieName + '=')
          );
          return;
        }
        
        // Handle cookie setting
        const newCookie = value.split(';')[0]; // Get just name=value part
        const cookieName = newCookie.split('=')[0];
        
        // Replace existing cookie or add new one
        const existingIndex = documentCookies.findIndex(cookie => 
          cookie.startsWith(cookieName + '=')
        );
        
        if (existingIndex >= 0) {
          documentCookies[existingIndex] = newCookie;
        } else {
          documentCookies.push(newCookie);
        }
      }),
      configurable: true
    });
  });

  describe('setCookie', () => {
    it('should set a cookie with correct name and value', () => {
      setCookie('test', 'value', 1);
      expect(document.cookie).toContain('test=value');
    });

    it('should set expiration date correctly', () => {
      const mockDate = new Date('2025-01-01T00:00:00Z');
      jest.spyOn(global, 'Date').mockImplementation(() => mockDate);

      setCookie('test', 'value', 1);
      
      expect(document.cookie).toContain('expires=Wed, 02 Jan 2025 00:00:00 GMT');
      
      (global.Date as unknown as jest.Mock).mockRestore();
    });

    it('should update existing cookie value', () => {
      setCookie('test', 'value1', 1);
      setCookie('test', 'value2', 1);
      
      expect(document.cookie).toContain('test=value2');
      expect(document.cookie.match(/test=/g)?.length).toBe(1);
    });

    it('should handle special characters in value', () => {
      setCookie('test', 'value with spaces', 1);
      expect(getCookie('test')).toBe('value with spaces');
    });
  });

  describe('getCookie', () => {
    it('should retrieve existing cookie value', () => {
      setCookie('test', 'value', 1);
      expect(getCookie('test')).toBe('value');
    });

    it('should return null for non-existent cookie', () => {
      expect(getCookie('nonexistent')).toBeNull();
    });

    it('should handle multiple cookies', () => {
      setCookie('test1', 'value1', 1);
      setCookie('test2', 'value2', 1);
      
      expect(getCookie('test1')).toBe('value1');
      expect(getCookie('test2')).toBe('value2');
    });

    it('should handle cookies with spaces around values', () => {
      // Manually set cookie with spaces
      document.cookie = 'test=  value  ';
      expect(getCookie('test')).toBe('value');
    });

    it('should handle cookies with special characters', () => {
      const specialValue = 'value!@#$%^&*()';
      setCookie('test', specialValue, 1);
      expect(getCookie('test')).toBe(specialValue);
    });

    it('should return exact matches only', () => {
      setCookie('test', 'value', 1);
      setCookie('test123', 'other', 1);
      
      expect(getCookie('test')).toBe('value');
    });
  });

  describe('deleteCookie', () => {
    it('should delete existing cookie', () => {
      setCookie('test', 'value', 1);
      deleteCookie('test');
      
      expect(getCookie('test')).toBeNull();
    });

    it('should not throw error when deleting non-existent cookie', () => {
      expect(() => deleteCookie('nonexistent')).not.toThrow();
    });

    it('should only delete specified cookie', () => {
      setCookie('test1', 'value1', 1);
      setCookie('test2', 'value2', 1);
      
      deleteCookie('test1');
      
      expect(getCookie('test1')).toBeNull();
      expect(getCookie('test2')).toBe('value2');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty string values', () => {
      setCookie('test', '', 1);
      expect(getCookie('test')).toBe('');
    });

    it('should handle empty string names', () => {
      setCookie('', 'value', 1);
      expect(getCookie('')).toBe('value');
    });

    it('should handle zero expiration days', () => {
      setCookie('test', 'value', 0);
      expect(getCookie('test')).toBe('value');
    });

    it('should handle negative expiration days', () => {
      setCookie('test', 'value', -1);
      expect(getCookie('test')).toBe('value');
    });

    it('should handle multiple sequential operations', () => {
      setCookie('test', 'value1', 1);
      expect(getCookie('test')).toBe('value1');
      
      setCookie('test', 'value2', 1);
      expect(getCookie('test')).toBe('value2');
      
      deleteCookie('test');
      expect(getCookie('test')).toBeNull();
    });
  });
});import { setCorsHeaders } from '../../src/utils/cors';
import { ServerResponse } from 'http';

describe('CORS Headers', () => {
  let res: jest.Mocked<ServerResponse>;
  
  beforeEach(() => {
    res = {
      setHeader: jest.fn(),
    } as any;
  });

  it('should set default CORS headers', () => {
    setCorsHeaders(res);
    expect(res.setHeader).toHaveBeenCalledWith('Access-Control-Allow-Origin', '*');
    expect(res.setHeader).toHaveBeenCalledWith('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, HEAD');
  });

  it('should handle custom origins array', () => {
    setCorsHeaders(res, { origins: ['http://localhost:3000', 'https://example.com'] });
    expect(res.setHeader).toHaveBeenCalledWith('Access-Control-Allow-Origin', 'http://localhost:3000,https://example.com');
  });
});import { generateErrorPage, handleError } from '../../src/utils/errorHandler';
import { IncomingMessage, ServerResponse } from 'http';

describe('Error Handler', () => {
  let req: jest.Mocked<IncomingMessage>;
  let res: jest.Mocked<ServerResponse>;
  const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();

  beforeEach(() => {
    req = {
      url: '/test',
      method: 'GET'
    } as any;
    res = {
      writeHead: jest.fn(),
      end: jest.fn()
    } as any;
  });

  afterEach(() => {
    consoleErrorSpy.mockClear();
  });

  it('should generate an error page', () => {
    const page = generateErrorPage(404, 'Not Found');
    expect(page).toContain('Error 404');
    expect(page).toContain('Not Found');
  });

  it('should handle errors with custom status codes', async () => {
    const error = new Error('Custom Error') as any;
    error.statusCode = 400;

    await handleError(error, req, res);
    expect(res.writeHead).toHaveBeenCalledWith(400, expect.any(Object));
    expect(res.end).toHaveBeenCalled();
  });
});import { generateETag } from '../../src/utils/etag';

describe('ETag Generator', () => {
  it('should generate a strong ETag by default', () => {
    const content = 'test content';
    const etag = generateETag(content);
    expect(etag).toMatch(/^"[a-f0-9]{32}"$/);
  });

  it('should generate a weak ETag when specified', () => {
    const content = 'test content';
    const etag = generateETag(content, { weak: true });
    expect(etag).toMatch(/^W\/"[a-f0-9]{32}"$/);
  });
});
import { injectMetaTags } from '../../src/utils/html';

describe('HTML Meta Tags Injection', () => {
  const baseHtml = '<!DOCTYPE html><html><head></head><body></body></html>';

  it('should inject basic meta tags', () => {
    const meta = {
      title: 'Test Page',
      description: 'Test Description'
    };
    const result = injectMetaTags(baseHtml, meta);
    expect(result).toContain('<title>Test Page</title>');
    expect(result).toContain('<meta name="description" content="Test Description">');
  });

  it('should handle OpenGraph tags', () => {
    const meta = {
      ogTitle: 'OG Title',
      ogDescription: 'OG Description'
    };
    const result = injectMetaTags(baseHtml, meta);
    expect(result).toContain('<meta property="og:title" content="OG Title">');
    expect(result).toContain('<meta property="og:description" content="OG Description">');
  });
});
import * as fs from 'fs';
import * as path from 'path';
import Logger from '../../src/utils/logger'; 

jest.mock('fs', () => ({
  ...jest.requireActual('fs'),
  appendFile: jest.fn(),
  existsSync: jest.fn(),
  mkdirSync: jest.fn(),
}));

jest.mock('path', () => ({
  ...jest.requireActual('path'),
  dirname: jest.fn(),
}));

describe('Logger', () => {
  const mockPath = path as jest.Mocked<typeof path>;
  const mockFs = fs as jest.Mocked<typeof fs>;
  const testLogDir = '/test/logs';

  beforeEach(() => {
    jest.clearAllMocks();
    mockPath.dirname.mockReturnValue(testLogDir);
    mockFs.existsSync.mockReturnValue(true);
    mockFs.mkdirSync.mockReturnValue(undefined);
    mockFs.appendFile.mockResolvedValue(Promise.resolve());
  });

  describe('Initialization', () => {
    it('should create logger without file path', () => {
      const logger = new Logger();
      expect(logger).toBeDefined();
    });

    it('should create logger with valid file path', () => {
      const logger = new Logger('/test/logs/app.log');
      expect(logger).toBeDefined();
    });

    it('should create log directory if it does not exist', () => {
      mockFs.existsSync.mockReturnValue(false);
      const logger = new Logger('/test/logs/app.log');
      expect(mockFs.mkdirSync).toHaveBeenCalledWith(testLogDir, { recursive: true });
    });

    it('should handle directory creation errors gracefully', () => {
      mockFs.existsSync.mockReturnValue(false);
      mockFs.mkdirSync.mockImplementation(() => {
        throw new Error('Permission denied');
      });

      expect(() => new Logger('/test/logs/app.log')).toThrow('Permission denied');
    });
  });

  describe('Logging Operations', () => {
    it('should log to console', () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
      const logger = new Logger();

      logger.log('Test message');

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Test message'));
      consoleSpy.mockRestore();
    });

    it('should format log messages with timestamp', () => {
      const logger = new Logger();
      const message = 'Test message';
      const formattedMessage = logger.formatMessage(message);

      expect(formattedMessage).toMatch(/\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\] Test message/);
    });

    it('should log to file when path provided', async () => {
      const logger = new Logger('/test/logs/app.log');
      await logger.log('File log message');

      expect(mockFs.appendFile).toHaveBeenCalledWith(
        '/test/logs/app.log',
        expect.stringContaining('File log message'),
        expect.any(Function)
      );
    });

    it('should handle file write errors gracefully', async () => {
      mockFs.appendFile.mockRejectedValue(new Error('Write error') as never);
      const logger = new Logger('/test/logs/app.log');

      await expect(logger.log('File log message')).rejects.toThrow('Write error');
    });
  });

  describe('Request Logging', () => {
    it('should log request details', () => {
      const logger = new Logger();
      const req = { method: 'GET', url: '/api/test' };
      logger.logRequest(req);

      expect(mockFs.appendFile).toHaveBeenCalledWith(
        expect.any(String),
        expect.stringContaining('GET /api/test'),
        expect.any(Function)
      );
    });

    it('should handle missing request properties gracefully', () => {
      const logger = new Logger();
      const req = { method: undefined, url: undefined };
      logger.logRequest(req);

      expect(mockFs.appendFile).toHaveBeenCalledWith(
        expect.any(String),
        expect.stringContaining('undefined undefined'),
        expect.any(Function)
      );
    });
  });

  describe('Clear Operation', () => {
    it('should clear log file when it exists', () => {
      mockFs.existsSync.mockReturnValue(true);
      const logger = new Logger('/test/logs/app.log');

      logger.clear();

      expect(mockFs.appendFile).toHaveBeenCalledWith('/test/logs/app.log', '', expect.any(Function));
    });

    it('should handle clear errors gracefully', () => {
      mockFs.appendFile.mockImplementation(() => {
        throw new Error('Clear error');
      });
      const logger = new Logger('/test/logs/app.log');

      expect(() => logger.clear()).toThrow('Clear error');
    });
  });
});


describe('Logger', () => {
  let mockFs: jest.Mocked<typeof fs>;
  
  beforeEach(() => {
    mockFs = fs as jest.Mocked<typeof fs>;
    mockFs.appendFile.mockResolvedValue(undefined);
  });

  it('should initialize without file path', () => {
    const logger = new Logger();
    expect(logger.getLogPath()).toBeNull();
  });

  it('should write to file when path provided', async () => {
    const logger = new Logger({ logFilePath: '/test.log' });
    await logger.log('test message');
    expect(mockFs.appendFile).toHaveBeenCalled();
  });

  it('should format messages with timestamp', async () => {
    const logger = new Logger();
    const consoleSpy = jest.spyOn(console, 'log');
    await logger.log('test');
    expect(consoleSpy).toHaveBeenCalledWith(
      expect.stringMatching(/\[\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/)
    );
  });
});

// Priority 4: Cookie Tests
describe('Cookie Utils', () => {
  beforeEach(() => {
    // Mock document.cookie
    Object.defineProperty(window.document, 'cookie', {
      writable: true,
      value: '',
    });
  });

  it('should set cookie with correct attributes', () => {
    setCookie('test', 'value', 1, {
      path: '/test',
      secure: true
    });
    
    expect(document.cookie).toContain('test=value');
    expect(document.cookie).toContain('path=/test');
    expect(document.cookie).toContain('secure');
  });

  it('should get cookie value', () => {
    document.cookie = 'test=value';
    expect(getCookie('test')).toBe('value');
  });

  it('should delete cookie', () => {
    setCookie('test', 'value', 1);
    deleteCookie('test');
    expect(getCookie('test')).toBeNull();
  });
});