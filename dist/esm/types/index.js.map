{"version":3,"file":"index.js","sources":["../../../../src/types/index.ts"],"sourcesContent":["// types/index.ts\r\nimport type { IncomingMessage, ServerResponse } from 'http';\r\n\r\n// Core Base Interfaces\r\nexport interface CacheStoreBase<T> {\r\n  get(key: string): T | undefined;\r\n  set(key: string, value: T): void;\r\n  clear(): void;\r\n}\r\n\r\nexport interface CorsOptionsBase {\r\n  origins?: string | string[];\r\n  methods?: string[];\r\n  allowedHeaders?: string[];\r\n  exposedHeaders?: string[];\r\n  credentials?: boolean;\r\n  maxAge?: number;\r\n}\r\n\r\nexport interface MetaTagsBase {\r\n  title?: string;\r\n  description?: string;\r\n  charset?: string;\r\n  viewport?: string;\r\n  [key: string]: string | undefined;\r\n}\r\n\r\nexport interface LoggerOptionsBase {\r\n  logFilePath?: string | null;\r\n  logLevel?: 'debug' | 'info' | 'warn' | 'error';\r\n}\r\n\r\n// Core Type Definitions\r\nexport type Middleware = (\r\n  req: IncomingMessage,\r\n  res: ServerResponse,\r\n  next: () => Promise<void>\r\n) => Promise<void>;\r\n\r\nexport type RouteHandler = (\r\n  req: IncomingMessage,\r\n  res: ServerResponse\r\n) => Promise<void>;\r\n\r\nexport type ErrorHandler = (\r\n  error: Error,\r\n  req: IncomingMessage,\r\n  res: ServerResponse\r\n) => Promise<void>;\r\n\r\n// File Handling Types\r\nexport interface StaticFileOptions {\r\n  root: string;\r\n  maxAge?: number;\r\n  index?: string[];\r\n  dotFiles?: 'ignore' | 'allow' | 'deny';\r\n  compression?: boolean;\r\n  etag?: boolean;\r\n  cacheSize?: number;\r\n}\r\n\r\nexport type StaticFileHandler = (\r\n  req: IncomingMessage,\r\n  res: ServerResponse,\r\n  options: StaticFileOptions\r\n) => Promise<void>;\r\n\r\nexport type BundleHandler = (\r\n  req: IncomingMessage,\r\n  res: ServerResponse,\r\n  bundlePath: string\r\n) => Promise<void>;\r\n\r\nexport type TemplateHandler = (\r\n  req: IncomingMessage,\r\n  res: ServerResponse,\r\n  templatePath: string\r\n) => Promise<void>;\r\n\r\n// Main Configuration Interfaces\r\nexport interface CacheOptions {\r\n  maxSize?: number;\r\n  ttl?: number;\r\n}\r\nexport type AnyFunction = (...args: any[]) => any;\r\n\r\nexport interface AsyncResult<T> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: Error;\r\n}\r\n\r\nexport interface AsyncOptions {\r\n  timeout?: number;\r\n  retries?: number;\r\n  onRetry?: (error: Error, attempt: number) => void;\r\n}\r\n\r\nexport interface CorsOptions extends CorsOptionsBase {}\r\n\r\nexport interface MetaTags extends MetaTagsBase {}\r\n\r\nexport interface LoggerOptions extends LoggerOptionsBase {}\r\n\r\nexport interface AeroSSRConfig {\r\n  port?: number;\r\n  cacheMaxAge?: number;\r\n  corsOrigins?: string | CorsOptions;\r\n  compression?: boolean;\r\n  logFilePath?: string | null;\r\n  bundleCache?: CacheStoreBase<string>;\r\n  templateCache?: CacheStoreBase<string>;\r\n  defaultMeta?: MetaTags;\r\n}\r\n\r\n// Utility Types\r\nexport interface AsyncResult<T> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: Error;\r\n}\r\n\r\nexport type AsyncHandler<T> = (...args: any[]) => Promise<AsyncResult<T>>;\r\n\r\n// Type Guards\r\nexport function isPromise<T = unknown>(value: unknown): value is Promise<T> {\r\n  return Boolean(\r\n    value && \r\n    typeof value === 'object' && \r\n    'then' in value && \r\n    typeof value.then === 'function'\r\n  );\r\n}\r\n\r\nexport function isError(error: unknown): error is Error {\r\n  return error instanceof Error;\r\n}\r\n\r\n// Re-export utility types\r\nexport type { ServerResponse, IncomingMessage } from 'http';\r\nexport * from '../utils/cache';\r\nexport * from '../utils/cors';\r\nexport * from '../utils/html';\r\nexport * from '../utils/logger';\r\nexport * from '../utils/errorHandler';\r\nexport * from '../utils/etag';\r\nexport * from '../utils/bundler';\r\nexport * from '../utils/async';\r\nexport * from '../utils/cookie';\r\nexport * from '../utils/async';\r\n\r\n// Create union type for all possible HTTP methods\r\nexport type HTTPMethod = \r\n  | 'GET'\r\n  | 'POST'\r\n  | 'PUT'\r\n  | 'DELETE'\r\n  | 'PATCH'\r\n  | 'HEAD'\r\n  | 'OPTIONS'\r\n  | 'TRACE'\r\n  | 'CONNECT';\r\n\r\n// Create RequiredConfig type with all required fields\r\nexport type RequiredConfig = Required<AeroSSRConfig> & {\r\n  corsOrigins: Required<CorsOptions>;\r\n};"],"names":[],"mappings":"AA4HA;AAUM,SAAU,OAAO,CAAC,KAAc,EAAA;IACpC,OAAO,KAAK,YAAY,KAAK,CAAC;AAChC;;;;"}